<template>
  <div class="timeline-comment-wrapper js-comment-container">
    <a href="/slightlyoff"><img alt="@slightlyoff" class="timeline-comment-avatar" height="44" src="https://avatars3.githubusercontent.com/u/97331?v=3&amp;s=88" width="44"></a>

    <div
      id="issue-162585129"
      class="comment previewable-edit timeline-comment js-comment js-task-list-container"
      data-body-version="502f93d7576c349587b8d420768a826f"
    >
      <div class="timeline-comment-header ">
        <div class="timeline-comment-actions" />

        <span
          class="timeline-comment-label

        tooltipped tooltipped-multiline tooltipped-s"
          aria-label="This user has been invited to collaborate on the ServiceWorker repository.
      "
        >
          Collaborator
        </span>

        <div class="timeline-comment-header-text">
          <strong>
            <a href="/slightlyoff" class="author">slightlyoff</a>
          </strong>

          commented

          <a href="#issue-162585129" class="timestamp" aria-label="Link to this comment">Jun 28, 2016</a>
        </div>
      </div>

      <div class="edit-comment-hide">
        <table class="d-block">
          <tbody class="d-block">
            <tr class="d-block">
              <td class="d-block comment-body markdown-body markdown-format js-comment-body">
                <p>Apologies in advance for the length of this issue.</p>
                <p>A few weeks ago I was discussing the topic of the upcoming <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=368813">"PlzNavigate" feature</a> with <a href="https://github.com/naskooskov" class="user-mention">@naskooskov</a>, <a href="https://github.com/n8schloss" class="user-mention">@n8schloss</a>, and <a href="https://github.com/bmaurer" class="user-mention">@bmaurer</a>.</p>
                <p>The TL;DR of PlzNavigate is that navigation actions in Chromium will not be handled as they currently are -- sending them through a Renderer process which then routes them to the Browser process for eventual dispatch by the network stack -- and will instead be immediately routed to the Browser-side network stack, improving time-to-navigation in the common (non-SW-controlled) case. This is beneficial in the PlzNavigate world which is much more aggressively multi-process oriented. Saving the time to create processes is a big win, particularly on Android which "features" particularly slow native process creation.</p>
                <p>In Chromium (and one assumes similarly architected browsers), this means that PlzNavigate-style request optimisation runs afoul of Service Worker handling of these requests. This isn't particularly satisfying as the SW may indeed choose to make a request for the top-level resource from the network. Indeed, waiting to issue these requests on Service Worker startup is being reported by large sites as a regression in the 10s or even hundred+ millisecond range. This is notable on sites which do not handle fetches for top-level documents but only want to use SWs for caching.</p>
                <p>What if we could enable PlzNavigate <em>and</em> remove the hit generated by SW startup?</p>
                <p>The idea in the following proposal is to allow a style of declarative navigation request decoration for these "preflight" navigation requests, allowing the Service Worker to use (or discard) the response. If no decoration is added and the site's SW decides to handle the request directly (e.g. with a <code>e.respondWith(fetch(e.request))</code>), nothing should break. Similarly, it's a goal to avoid sending the results of the "preflight" request to the document without the Service Worker's involvement.</p>
                <p>To accomplish this, the proposal we sketched out on the whiteboard was to allow the <code>onfetch</code> event that corresponds to the navigation to have access to the original (preflight) response. To enable a savvy server-side to repurpose this preflight navigation to, e.g., send up-to-date data in a different format than HTML (imagine JSON or similar), we'd also allow the Service Worker to register a header to pass along with the preflight'd navigation request. All together, the strawman looks roughly like:</p>
                <div class="highlight highlight-source-js">
                  <pre><span class="pl-smi">self</span>.<span class="pl-en">onactivate</span> <span class="pl-k">=</span> (<span class="pl-smi">e</span>) <span class="pl-k">=&gt;</span> {
  <span class="pl-c">// If unset, preflight requests are sent without special marking</span>
  <span class="pl-smi">e</span>.<span class="pl-en">setPreflightHeader</span>(<span class="pl-s"><span class="pl-pds">"</span>X-Site-Specific-Header<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>thinger<span class="pl-pds">"</span></span>);

  <span class="pl-c">// ...</span>
}

<span class="pl-smi">self</span>.<span class="pl-en">onfetch</span> <span class="pl-k">=</span> (<span class="pl-smi">e</span>) <span class="pl-k">=&gt;</span> {
  <span class="pl-k">if</span> (<span class="pl-smi">e</span>.<span class="pl-smi">preflightResponse</span>) {
    <span class="pl-c">// This is a navigation fetch which has already been issued.</span>
    <span class="pl-c">// If the `preflightResponse` isn't used, then everything proceeds as</span>
    <span class="pl-c">// if it hadn't been sent in the first place.</span>
  }
}</pre>
                </div>
                <p>Obviously the names are bike-sheddable. The goal however isn't to be super declarative about deciding what "routes" are handled in which style. Instead, it's to allow the maximum of flexibility for cooperating servers and clients to eliminate SW startup latency.</p>
                <p>Thoughts?</p>
                <p>/cc <a href="https://github.com/jakearchibald" class="user-mention">@jakearchibald</a> <a href="https://github.com/wanderview" class="user-mention">@wanderview</a> <a href="https://github.com/jungkees" class="user-mention">@jungkees</a> <a href="https://github.com/mkruisselbrink" class="user-mention">@mkruisselbrink</a></p>
              </td>
            </tr>
          </tbody>
        </table>

        <div class="comment-reactions  js-reactions-container " />
      </div>
    </div>
  </div>
</template>

<style lang="scss">
@import '~assets/scss/components/CommentItem.scss';
</style>
